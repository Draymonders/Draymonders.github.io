- 限流
    - 漏桶，请求先进入到漏桶里,漏桶以一定的速度出水，接口有响应速率
    - 令牌桶，每秒生产固定数量的令牌，处理请求需要先拿到令牌
    - 差异: 令牌桶能处理峰时流量

- 动态代理，JDK原生和cglib
    - 原生JDK是基于接口实现的, 实现`InvocationHandler`接口里的`invoke`方法，接着调用`Proxy.newProxyInstance`方法，传入类加载，接口，以及需要代理的对象
    - cglib是基于`继承`(字节码增强技术)实现的，实现`MethodInterceptor`接口里的`intercept`方法,接着`new Enhancer()`并且`setSuperclass()`和`setCallback`

- 红黑树,AVL对比,引申B,B+树(B+中间不存节点)

- [dubbo 负载均衡算法](https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/)
    - 加权随机算法
        * 比如权重`[1,2,3]`, 那么分为`[[0,1), [1,3), [3,6)]`, 随机6以内的数，落在哪个区间算哪个
        * warm up, 服务刚启动先降权，后满权
    - 加权最小连接数
        * 拿到最小连接数的节点组(可能会有多个最小连接数相同的节点), 然后节点组进行加权随机算法
    - 一致性hash算法
        * 将服务提供者映射到圆环上，并且引入虚拟节点
            * 一个物理节点充当多个虚拟节点，目的是为了防止由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量请求的情况
        * ConsistentHashLoadBalance **不关心权重**
    - 加权轮询
        * 初版的代码: 求加权的和，每次调用产生一个序号(从0开始)，对加权的和取余，余数一直递减，捡到0对应的`invoker`即为将要调用的节点(问题在于如果加权的和很大，每次减一，效率过低)